#!/bin/bash

# X509 tooling is shit. keytool is shit. openssl is shit. It's all shit.
# A shit sandwich, where the bread, the butter and the plate are all made
# of the foulest fucking catshit imaginable, covered in dogshit sauce in a
# house made of chickenshit.

# But we still have to deal with the fucking hateful stuff. So here goes.
# How to make the shittiest fucking tools in the known universe *usable*...

usage() {
    cat <<EOF
Usage: $0 <command> [<options> ...]

Where <command> is one of:

probe <url> [<url> ...]
    Connect to each <url> and list the certificates in use

list <file> [<file> ...]
    Parse each <file> and list the certificates therein. PEM and JKS formats
    are supported (and automatically detected).
EOF
    exit 1
}

# https://stackoverflow.com/a/3352015/1485960
trim() {
    local var="$*"
    # remove leading whitespace characters
    var="${var#"${var%%[![:space:]]*}"}"
    # remove trailing whitespace characters
    var="${var%"${var##*[![:space:]]}"}"
    echo -n "$var"
}

getline() {
    local stream="$1"
    local term="$2"
    local out=$(echo "$stream" | egrep "$term")
    out=${out##*"${term}"}
    echo -n "$out"
}

getpara() {
    local stream="$1"
    local term="$2"
    local out=$(echo "$stream"|egrep -C1 "$term"|tail -1)
    out=$(trim $out)
    echo -n "$out"
}

# Convert a selection of PEM fields into JSON format
pem2json() {
    local x509text=$(echo "$1" | openssl x509 -text)
    local subject=$(getline "$x509text" "  Subject: ")
    local end=$(getline "$x509text" "  Not After : ")
    local start=$(getline "$x509text" "  Not Before: ")
    local san=$(getpara "$x509text" "X509v3 Subject Alternative Name:")
    local serial=$(getpara "$x509text" "Serial Number:")
    local id=$(getpara "$x509text" "X509v3 Subject Key Identifier:")
    local ca=$(getpara "$x509text" "X509v3 Authority Key Identifier:")
    ca="${ca#keyid:}"
    cat <<EOF
{
"subject": "$subject",
"san": "$san",
"serial": "$serial",
"id": "$id",
"ca": "$ca",
"start": "$start",
"end": "$end"
}
EOF
}

parsejks() {
    local keystore="$1"
    local json=()
    local aliases=$(keytool -keystore $keystore -list </dev/null 2>/dev/null|grep -C1 "Certificate fingerprint"|head -1|awk -F, '{print $1}')
    for alias in $aliases; do
        local output=$(keytool -keystore $keystore -exportcert -rfc -alias $alias </dev/null 2>/dev/null)
        json=("${json[@]}" "\"$alias\": $(pem2json "$output")")
    done
    echo -n "\"$keystore\": { \"_type\": \"jks\", " $(IFS=, ; echo "${json[*]}") " }"
}

parsepem() {
    local pemfile="$1"
    local json=()
    local numcerts=$(egrep --count "^-----BEGIN CERTIFICATE-----" $pemfile)
    for count in $(seq 1 $numcerts); do
        local output=$(perl -e '$count='$count'; while(<>) { if(/-----BEGIN CERTIFICATE-----/) {$count--}; if($count==0) {print;} }' < $pemfile)
        json=("${json[@]}" "\"cert$count\": $(pem2json "$output")")
    done
    echo -n "\"$pemfile\": { \"_type\": \"pem\", " $(IFS=, ; echo "${json[*]}") " }"
}

####


case $1 in

probe)
    shift
    [[ $1 ]] || usage
    json_total=()
    for url in $*; do
        url=${url##https://}
        url=${url%%/*}
        if [[ "${url%:*}" == "$url" ]]; then
            url="$url:443"
        fi
        output="$(openssl s_client -connect $url </dev/null 2>/dev/null)"
        json_total=("${json_total[@]}" "\"$url\": $(pem2json "$output")")
    done
    echo "{ " $(IFS=, ; echo "${json_total[*]}") " }"
    ;;

list)
    shift
    [[ $1 ]] || usage
    json_total=()
    for filename in $*; do
        if file $filename | grep -q "Java KeyStore"; then
            json_total=("${json_total[@]}" "$(parsejks $filename)")
        elif file $filename | grep -q "PEM"; then
            json_total=("${json_total[@]}" "$(parsepem $filename)")
        else
            json_total=("${json_total[@]}" "\"$filename\": { \"_type\": \"unknown\"}")
        fi
    done
    echo "{ " $(IFS=, ; echo "${json_total[*]}") " }"
    ;;

*)
    usage
    ;;

esac
